using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Moq;
using NiyaCRM.Core;
using NiyaCRM.Core.Tenants;
using NiyaCRM.Infrastructure.Data;
using Shouldly;
using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace NiyaCRM.Tests.Unit.Infrastructure.Data
{
    public class UnitOfWorkTests
    {
        private readonly Mock<DbContext> _mockDbContext;
        private readonly Mock<IServiceProvider> _mockServiceProvider;
        private readonly UnitOfWork _unitOfWork;

        public UnitOfWorkTests()
        {
            // Use DbContext as the base class to mock instead of ApplicationDbContext
            _mockDbContext = new Mock<DbContext>();
            _mockServiceProvider = new Mock<IServiceProvider>();
            
            // Create UnitOfWork with the mocked DbContext
            _unitOfWork = new UnitOfWork(_mockDbContext.Object, _mockServiceProvider.Object);
        }

        [Fact]
        public void GetRepository_ShouldReturnRepositoryInstance()
        {
            // Arrange
            var mockRepo = new Mock<ITenantRepository>();
            
            _mockServiceProvider
                .Setup(sp => sp.GetService(typeof(ITenantRepository)))
                .Returns(mockRepo.Object);
            
            // Act
            var repository = _unitOfWork.GetRepository<ITenantRepository>();
            
            // Assert
            repository.ShouldNotBeNull();
            repository.ShouldBe(mockRepo.Object);
        }
        
        [Fact]
        public void GetRepository_ShouldCacheRepositories()
        {
            // Arrange
            var mockRepo = new Mock<ITenantRepository>();
            
            _mockServiceProvider
                .Setup(sp => sp.GetService(typeof(ITenantRepository)))
                .Returns(mockRepo.Object);
            
            // Act
            var repository1 = _unitOfWork.GetRepository<ITenantRepository>();
            var repository2 = _unitOfWork.GetRepository<ITenantRepository>();
            
            // Assert
            repository1.ShouldBe(repository2); // Same instance should be returned
            _mockServiceProvider.Verify(sp => sp.GetService(typeof(ITenantRepository)), Times.Once);
        }
        
        [Fact]
        public async Task SaveChangesAsync_ShouldCallDbContextSaveChanges()
        {
            // Arrange
            _mockDbContext
                .Setup(ctx => ctx.SaveChangesAsync(It.IsAny<CancellationToken>()))
                .ReturnsAsync(1);
            
            // Act
            var result = await _unitOfWork.SaveChangesAsync();
            
            // Assert
            result.ShouldBe(1);
            _mockDbContext.Verify(ctx => ctx.SaveChangesAsync(It.IsAny<CancellationToken>()), Times.Once);
        }
        
        [Fact]
        public async Task TransactionMethods_ShouldWorkCorrectly()
        {
            // Arrange
            var mockTransaction = new Mock<IDbContextTransaction>();
            
            _mockDbContext
                .Setup(ctx => ctx.Database.BeginTransactionAsync(It.IsAny<CancellationToken>()))
                .ReturnsAsync(mockTransaction.Object);
            
            // Act & Assert - BeginTransactionAsync
            var transaction = await _unitOfWork.BeginTransactionAsync();
            transaction.ShouldNotBeNull();
            
            // Verify CommitAsync
            await _unitOfWork.CommitAsync();
            mockTransaction.Verify(t => t.CommitAsync(It.IsAny<CancellationToken>()), Times.Once);
            
            // Verify RollbackAsync
            await _unitOfWork.RollbackAsync();
            mockTransaction.Verify(t => t.RollbackAsync(It.IsAny<CancellationToken>()), Times.Once);
        }
    }
}
